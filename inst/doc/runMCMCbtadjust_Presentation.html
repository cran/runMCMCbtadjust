<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>runMCMCbtadjust Presentation</title>
<style type="text/css">
/**
 * Prism.s theme ported from highlight.js's xcode style
 */
pre code {
  padding: 1em;
}
.token.comment {
  color: #007400;
}
.token.punctuation {
  color: #999;
}
.token.tag,
.token.selector {
  color: #aa0d91;
}
.token.boolean,
.token.number,
.token.constant,
.token.symbol {
  color: #1c00cf;
}
.token.property,
.token.attr-name,
.token.string,
.token.char,
.token.builtin {
  color: #c41a16;
}
.token.inserted {
  background-color: #ccffd8;
}
.token.deleted {
  background-color: #ffebe9;
}
.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
  color: #9a6e3a;
}
.token.atrule,
.token.attr-value,
.token.keyword {
  color: #836c28;
}
.token.function,
.token.class-name {
  color: #DD4A68;
}
.token.regex,
.token.important,
.token.variable {
  color: #5c2699;
}
.token.important,
.token.bold {
  font-weight: bold;
}
.token.italic {
  font-style: italic;
}
</style>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
  box-sizing: border-box;
}
body, .footnotes, code { font-size: .9em; }
li li { font-size: .95em; }
*, *:before, *:after {
  box-sizing: inherit;
}
pre, img { max-width: 100%; }
pre, pre:hover {
  white-space: pre-wrap;
  word-break: break-all;
}
pre code {
  display: block;
  overflow-x: auto;
}
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre) > code, code[class] { background-color: #F8F8F8; }
code.language-undefined, pre > code:not([class]) {
  background-color: inherit;
  border: 1px solid #eee;
}
table {
  margin: auto;
  border-top: 1px solid #666;
}
table thead th { border-bottom: 1px solid #ddd; }
th, td { padding: 5px; }
thead, tfoot, tr:nth-child(even) { background: #eee; }
blockquote {
  color: #666;
  margin: 0;
  padding-left: 1em;
  border-left: 0.5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC .numbered li { list-style: none; }
#TOC .numbered { padding-left: 0; }
#TOC .numbered ul { padding-left: 1em; }
table, .body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.footnote-ref a::before { content: "["; }
.footnote-ref a::after { content: "]"; }
.footnotes::before {
  content: "";
  display: block;
  max-width: 20em;
}

@media print {
  body {
    font-size: 12pt;
    max-width: 100%;
  }
  tr, img { page-break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  pre { white-space: pre; }
}
</style>
</head>
<body>
<div class="include-before">
</div>
<div class="frontmatter">
<div class="title"><h1>runMCMCbtadjust Presentation</h1></div>
<div class="author"><h2>Frédéric Gosselin</h2></div>
<div class="date"><h3>2023-07-19</h3></div>
</div>
<div class="body">
<h1 id="introduction">Introduction</h1>
<p>This file is meant to present the function <code>runMCMC_btadjust()</code> in the <code>runMCMCbtadjust</code> package. The aim of this function is to run a Markov Chain Monte Carlo (MCMC) for a specified Bayesian model while adapting automatically the burn-in and thinning parameters to meet pre-specified targets in terms of MCMC convergence and number of effective values of MCMC outputs - where the term “number of effective values” for the MCMC outputs refers to sample size adjusted for autocorrelation. This is done in only one call to the function that repeatedly calls the MCMC until criteria for convergence and number of effective values are met. This allows to obtain a MCMC output that is out of the transient phase of the MCMC (convergence) and that contains a pre-specified number of nearly independent draws from the posterior distribution (number of effective values).</p>
<p>This function has four main advantages: (i) it saves the analyst’s programming time since he/she does not have to repeatedly diagnose and re-run MCMCs until desired levels of convergence and number of effective values are reached; (ii) it allows a minimal, normalized quality control of MCMC outputs by allowing to meet pre-specified levels in terms of convergence and number of quasi-independent values; (iii) it may save computer’s time when compared to cases where we have to restart the MCMC from the beginning if it has not converged or reached the specified number of effective values (as e.g. with <code>runMCMC</code> function in <code>NIMBLE</code>); and (iv) it can be applied with different MCMC R languages.</p>
<p>Indeed, <code>runMCMC_btadjust()</code> uses other Bayesian packages to fit the MCMC. At present, only the <code>JAGS</code>, <code>NIMBLE</code> and <code>greta</code> languages can be used as these are the main Bayesian languages in R known by the package author and that permit to continue an already fitted MCMC - which is required for numerical efficiency. We will here show how to fit and compare a very simple model under these three languages, using the possibilities allowed by <code>runMCMC_btadjust()</code>. Our model is one of the simplest statistical model we could think of: inspired from @Kery_2010, we model data of weights of 1,000 Pilgrim falcons (<em>Falco peregrinus</em>) simulated from a Gaussian distribution with mean 600 grams and standard error 30 grams:</p>
<pre><code class="language-r">set.seed(1)
y1000&lt;-rnorm(n=1000,mean=600,sd=30)
</code></pre>
<p>This document is made to provide simple examples with the three languages - <code>JAGS</code>, <code>NIMBLE</code> and <code>greta</code>. Yet only the languages that are available/installed on the computer compiling this document  will be developed. And if <code>NIMBLE</code> is not available, no example will be developed given that Nimble is the reference example herein.</p>
<h2 id="nimble">NIMBLE</h2>
<p>We start with fitting the example with <code>NIMBLE</code> (cf. <a href="https://r-nimble.org/">https://r-nimble.org/</a>).</p>
<pre><code class="language-r">
library(runMCMCbtadjust)
library(nimble)
#&gt; Warning: le package 'nimble' a été compilé avec la version R 4.3.1
</code></pre>
<p>As <code>NIMBLE</code> distinguishes data that have random distributions from other data, we specify two distinct lists to contain these:</p>
<pre><code class="language-r">
ModelData &lt;-list(mass = y1000)
ModelConsts &lt;- list(nobs = length(y1000))
</code></pre>
<p>We then write our Bayesian code within R with the <code>nimbleCode</code> function in the <code>nimble</code> package:</p>
<pre><code class="language-r"> ModelCode&lt;-nimbleCode(
  {
    # Priors
    population.mean ~ dunif(0,5000)
    population.sd ~ dunif(0,100)
    
    # Normal distribution parameterized by precision = 1/variance in Nimble
    population.variance &lt;- population.sd * population.sd
    precision &lt;- 1 / population.variance
  
    # Likelihood
    for(i in 1:nobs){
      mass[i] ~ dnorm(population.mean, precision)
    }
  })
</code></pre>
<p>Our -optional- next step is to specify starting values for model’s parameters. This is done by first writing a function that is repetitively called for each chain. We - also optionally - indicate the names of parameters to be saved and diagnosed in a vector called <code>params</code>:</p>
<pre><code class="language-r">ModelInits &lt;- function()
{list (population.mean = rnorm(1,600,90), population.sd = runif(1, 1, 30))}
  
Nchains &lt;- 3

set.seed(1)
Inits&lt;-lapply(1:Nchains,function(x){ModelInits()})

#specifying the names of parameters to analyse and save:
params &lt;- c(&quot;population.mean&quot;, &quot;population.sd&quot;) 
</code></pre>
<p>We are now ready to launch <code>runMCMC_btadjust()</code>: since we use <code>NIMBLE</code>, we must specify arguments <code>code</code>, <code>data</code>, <code>constants</code> (see below) as well as <code>MCMC_language=&quot;Nimble&quot;</code>. We first do it on one chain (argument <code>Nchains=1</code>) using in the <code>control</code> list argument <code>neff.method=&quot;Coda&quot;</code> to use the <code>Coda</code> method to calculate the number of effective parameters and <code>convtype=&quot;Geweke&quot;</code> to use the Geweke method to diagnose convergence, with the pre-specified maximum - over analyzed parameters - convergence of 1.05 (<code>conv.max=1.05</code>) and the minimum - over analyzed parameters - number of effective values of 1,000 (<code>neff.min=1000</code>). Other arguments that are the same for all MCMC languages include <code>params</code> (parameter names to diagnose and save), <code>inits</code> (initial values), <code>niter.min</code> (minimum number of iterations), <code>niter.max</code> (maximum number of iterations), <code>nburnin.min</code>, <code>nburnin.max</code>   <code>thin.min</code>, <code>thin.max</code> (minimum and maximum number of iterations for respectively the burn-in and thinning parameters):</p>
<pre><code class="language-r">out.mcmc.Coda.Geweke&lt;-runMCMC_btadjust(code=ModelCode, constants = ModelConsts, data = ModelData, MCMC_language=&quot;Nimble&quot;,
    Nchains=1, params=params, inits=Inits[1],
    niter.min=1000, niter.max=300000,
    nburnin.min=100, nburnin.max=200000, 
    thin.min=1, thin.max=1000,
    conv.max=1.05, neff.min=1000,
    control=list(neff.method=&quot;Coda&quot;, convtype=&quot;Geweke&quot;),
    control.MCMC=list(showCompilerOutput=FALSE))
#&gt; ===== Monitors =====
#&gt; thin = 1: population.mean, population.sd
#&gt; ===== Samplers =====
#&gt; RW sampler (2)
#&gt;   - population.mean
#&gt;   - population.sd
#&gt; [1] &quot;###################################################################################&quot;
#&gt; |-------------|-------------|-------------|-------------|
#&gt; |-------------------------------------------------------|
#&gt; [1] &quot;Case of niter update: Non convergence&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; |-------------|-------------|-------------|-------------|
#&gt; |-------------------------------------------------------|
#&gt; [1] &quot;raw multiplier of thin:  4.837&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; [1] &quot;Case of niter update: Convergence and trying to reach end of MCMC at the end of next cycle&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; |-------------|-------------|-------------|-------------|
#&gt; |-------------------------------------------------------|
#&gt; [1] &quot;raw multiplier of thin:  1.329&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; [1] &quot;Case of niter update: Convergence and trying to reach end of MCMC at the end of next cycle&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; |-------------|-------------|-------------|-------------|
#&gt; |-------------------------------------------------------|
</code></pre>
<p>We then run the MCMC with <code>Nchains</code> MCMC chains, the -default- Gelman-Rubin diagnostic of convergence and the -default- <code>rstan</code> method for calculating the number of effective values:</p>
<pre><code class="language-r">out.mcmc&lt;-runMCMC_btadjust(code=ModelCode, constants = ModelConsts, data = ModelData, MCMC_language=&quot;Nimble&quot;,
    Nchains=Nchains, params=params, inits=Inits,
    niter.min=1000, niter.max=300000,
    nburnin.min=100, nburnin.max=200000, 
    thin.min=1, thin.max=1000,
    conv.max=1.05, neff.min=1000,
    control.MCMC=list(showCompilerOutput=FALSE))
#&gt; ===== Monitors =====
#&gt; thin = 1: population.mean, population.sd
#&gt; ===== Samplers =====
#&gt; RW sampler (2)
#&gt;   - population.mean
#&gt;   - population.sd
#&gt; ===== Monitors =====
#&gt; thin = 1: population.mean, population.sd
#&gt; ===== Samplers =====
#&gt; RW sampler (2)
#&gt;   - population.mean
#&gt;   - population.sd
#&gt; ===== Monitors =====
#&gt; thin = 1: population.mean, population.sd
#&gt; ===== Samplers =====
#&gt; RW sampler (2)
#&gt;   - population.mean
#&gt;   - population.sd
#&gt; [1] &quot;###################################################################################&quot;
#&gt; |-------------|-------------|-------------|-------------|
#&gt; |-------------------------------------------------------|
#&gt; |-------------|-------------|-------------|-------------|
#&gt; |-------------------------------------------------------|
#&gt; |-------------|-------------|-------------|-------------|
#&gt; |-------------------------------------------------------|
#&gt; [1] &quot;Case of niter update: Non convergence&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; |-------------|-------------|-------------|-------------|
#&gt; |-------------------------------------------------------|
#&gt; |-------------|-------------|-------------|-------------|
#&gt; |-------------------------------------------------------|
#&gt; |-------------|-------------|-------------|-------------|
#&gt; |-------------------------------------------------------|
#&gt; [1] &quot;raw multiplier of thin:  6.643&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; [1] &quot;Case of niter update: Convergence and trying to reach end of MCMC at the end of next cycle&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; |-------------|-------------|-------------|-------------|
#&gt; |-------------------------------------------------------|
#&gt; |-------------|-------------|-------------|-------------|
#&gt; |-------------------------------------------------------|
#&gt; |-------------|-------------|-------------|-------------|
#&gt; |-------------------------------------------------------|
#&gt; [1] &quot;raw multiplier of thin:  1.453&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; [1] &quot;Case of niter update: Convergence and trying to reach end of MCMC at the end of next cycle&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; |-------------|-------------|-------------|-------------|
#&gt; |-------------------------------------------------------|
#&gt; |-------------|-------------|-------------|-------------|
#&gt; |-------------------------------------------------------|
#&gt; |-------------|-------------|-------------|-------------|
#&gt; |-------------------------------------------------------|
</code></pre>
<p>We compare the characteristics of the two MCMCs, both in terms of burn-in, thinning parameter, number of iterations and in terms of time (both total time and CPU time).</p>
<p>Table: Comparison of the efficiency of first two NIMBLE models:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="right">Nimble.Coda.Geweke</th>
<th align="right">Nimble.default</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">converged</td>
<td align="right">1.0000</td>
<td align="right">1.0000</td>
</tr>
<tr>
<td align="left">burnin</td>
<td align="right">1050.0000</td>
<td align="right">574.0000</td>
</tr>
<tr>
<td align="left">thin</td>
<td align="right">5.0000</td>
<td align="right">7.0000</td>
</tr>
<tr>
<td align="left">niter.tot</td>
<td align="right">8530.0000</td>
<td align="right">4226.0000</td>
</tr>
<tr>
<td align="left">duration</td>
<td align="right">29.1725</td>
<td align="right">62.5618</td>
</tr>
<tr>
<td align="left">duration.MCMC.preparation</td>
<td align="right">25.0263</td>
<td align="right">55.7112</td>
</tr>
<tr>
<td align="left">duration.MCMC.transient</td>
<td align="right">0.1070</td>
<td align="right">0.2024</td>
</tr>
<tr>
<td align="left">duration.MCMC.asymptotic</td>
<td align="right">0.7623</td>
<td align="right">1.2878</td>
</tr>
<tr>
<td align="left">duration.btadjust</td>
<td align="right">3.2768</td>
<td align="right">5.3603</td>
</tr>
<tr>
<td align="left">CPUduration</td>
<td align="right">8.0200</td>
<td align="right">17.0400</td>
</tr>
<tr>
<td align="left">CPUduration.MCMC.preparation</td>
<td align="right">6.5500</td>
<td align="right">14.0400</td>
</tr>
<tr>
<td align="left">CPUduration.MCMC.transient</td>
<td align="right">0.1071</td>
<td align="right">0.2037</td>
</tr>
<tr>
<td align="left">CPUduration.MCMC.asymptotic</td>
<td align="right">0.7629</td>
<td align="right">1.2963</td>
</tr>
<tr>
<td align="left">CPUduration.btadjust</td>
<td align="right">0.6000</td>
<td align="right">1.5000</td>
</tr>
</tbody>
</table>
<p>We acknowledge that the Coda.Geweke algorithm takes much less time (rows named <code>duration</code> and <code>CPUduration</code> in the previous table) than the classical setting  to prepare data (rows named <code>duration.MCMC.preparation</code> and <code>CPUduration.MCMC.preparation</code>)- as <code>NIMBLE</code> takes quite a lot of time to prepare each MCMC chain - and we have 3 chains to prepare in the default setting compared to 1 with Geweke.</p>
<p>We also notice that the Coda.Geweke algorithm uses more time (<code>duration.MCMC.transient</code> and <code>CPUduration.MCMC.transient</code>) and iterations (<code>burnin</code>) to converge while the default setting takes more time for the asymptotic phase (<code>duration.MCMC.asymptotic</code> and <code>CPUduration.MCMC.asymptotic</code>), linked to a greater thinning parameter (<code>thin</code>). This transient part should be linked to the different behaviors between Geweke and Gelman-Rubin convergence diagnostics, while the differences in thinning parameters might be linked to the different methods in calculating the number of effective parameters. We therefore run a third MCMC on one chain with Geweke diagnostic but the default, rstan method for number of effective values.</p>
<pre><code class="language-r">
out.mcmc.Geweke&lt;-runMCMC_btadjust(code=ModelCode, constants = ModelConsts, data = ModelData, MCMC_language=&quot;Nimble&quot;,
    Nchains=1, params=params, inits=Inits[1],
    niter.min=1000, niter.max=300000,
    nburnin.min=100, nburnin.max=200000, 
    thin.min=1, thin.max=1000,
    conv.max=1.05, neff.min=1000,
    control=list(convtype=&quot;Geweke&quot;),
    control.MCMC=list(showCompilerOutput=FALSE))
#&gt; ===== Monitors =====
#&gt; thin = 1: population.mean, population.sd
#&gt; ===== Samplers =====
#&gt; RW sampler (2)
#&gt;   - population.mean
#&gt;   - population.sd
#&gt; [1] &quot;###################################################################################&quot;
#&gt; |-------------|-------------|-------------|-------------|
#&gt; |-------------------------------------------------------|
#&gt; [1] &quot;Case of niter update: Non convergence&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; |-------------|-------------|-------------|-------------|
#&gt; |-------------------------------------------------------|
#&gt; [1] &quot;raw multiplier of thin:  4.852&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; [1] &quot;Case of niter update: Convergence and trying to reach end of MCMC at the end of next cycle&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; |-------------|-------------|-------------|-------------|
#&gt; |-------------------------------------------------------|
#&gt; [1] &quot;raw multiplier of thin:  1.483&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; [1] &quot;Case of niter update: Convergence and trying to reach end of MCMC at the end of next cycle&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; |-------------|-------------|-------------|-------------|
#&gt; |-------------------------------------------------------|
#&gt; [1] &quot;raw multiplier of thin:  1.536&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; [1] &quot;Case of niter update: Convergence and trying to reach end of MCMC at the end of next cycle&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; |-------------|-------------|-------------|-------------|
#&gt; |-------------------------------------------------------|
#&gt; [1] &quot;raw multiplier of thin:  1.201&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; [1] &quot;Case of niter update: Convergence and trying to reach end of MCMC at the end of next cycle&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; |-------------|-------------|-------------|-------------|
#&gt; |-------------------------------------------------------|
</code></pre>
<p>We compare the characteristics of the three <code>NIMBLE</code> MCMCs,</p>
<p>Table: Comparison of the efficiency of the three NIMBLE models:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="right">Nimble.Coda.Geweke</th>
<th align="right">Nimble.Geweke</th>
<th align="right">Nimble.default</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">converged</td>
<td align="right">1.0000</td>
<td align="right">1.0000</td>
<td align="right">1.0000</td>
</tr>
<tr>
<td align="left">burnin</td>
<td align="right">1050.0000</td>
<td align="right">3035.0000</td>
<td align="right">574.0000</td>
</tr>
<tr>
<td align="left">thin</td>
<td align="right">5.0000</td>
<td align="right">10.0000</td>
<td align="right">7.0000</td>
</tr>
<tr>
<td align="left">niter.tot</td>
<td align="right">8530.0000</td>
<td align="right">16745.0000</td>
<td align="right">4226.0000</td>
</tr>
<tr>
<td align="left">duration</td>
<td align="right">29.1725</td>
<td align="right">30.7012</td>
<td align="right">62.5618</td>
</tr>
<tr>
<td align="left">duration.MCMC.preparation</td>
<td align="right">25.0263</td>
<td align="right">21.8698</td>
<td align="right">55.7112</td>
</tr>
<tr>
<td align="left">duration.MCMC.transient</td>
<td align="right">0.1070</td>
<td align="right">0.3251</td>
<td align="right">0.2024</td>
</tr>
<tr>
<td align="left">duration.MCMC.asymptotic</td>
<td align="right">0.7623</td>
<td align="right">1.4685</td>
<td align="right">1.2878</td>
</tr>
<tr>
<td align="left">duration.btadjust</td>
<td align="right">3.2768</td>
<td align="right">7.0377</td>
<td align="right">5.3603</td>
</tr>
<tr>
<td align="left">CPUduration</td>
<td align="right">8.0200</td>
<td align="right">8.0400</td>
<td align="right">17.0400</td>
</tr>
<tr>
<td align="left">CPUduration.MCMC.preparation</td>
<td align="right">6.5500</td>
<td align="right">5.5500</td>
<td align="right">14.0400</td>
</tr>
<tr>
<td align="left">CPUduration.MCMC.transient</td>
<td align="right">0.1071</td>
<td align="right">0.3244</td>
<td align="right">0.2037</td>
</tr>
<tr>
<td align="left">CPUduration.MCMC.asymptotic</td>
<td align="right">0.7629</td>
<td align="right">1.4656</td>
<td align="right">1.2963</td>
</tr>
<tr>
<td align="left">CPUduration.btadjust</td>
<td align="right">0.6000</td>
<td align="right">0.7000</td>
<td align="right">1.5000</td>
</tr>
</tbody>
</table>
<p>Results do not corroborate our above expectations: indeed, first the Geweke model does not converge within the same number of iterations as the Coda.Geweke one (row <code>burnin</code>), which is strange since they use the same method for diagnosing convergence and the same seed. Second, the thinning parameter was not increased when changing from Coda.Geweke to Geweke as expected above, but actually decreased (row <code>thin</code>).</p>
<p>We now turn to the comparison of the statistical parameter outputs. We use two sample Kolmogorov-Smirnov tests to compare each parameter by pairs of MCMC methods:</p>
<p>Table: P-values of paired Kolmogorov-Smirnov tests of output parameters (columns) between the first three NIMBLE models (rows):</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="right">mean</th>
<th align="right">sd</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">default vs. Geweke</td>
<td align="right">0.30017</td>
<td align="right">0.25460</td>
</tr>
<tr>
<td align="left">Coda.Geweke vs. Geweke</td>
<td align="right">0.37510</td>
<td align="right">0.95150</td>
</tr>
<tr>
<td align="left">Default vs. Coda.Geweke</td>
<td align="right">0.06526</td>
<td align="right">0.10937</td>
</tr>
</tbody>
</table>
<p>The p-values associated to the KS tests are not very small - only one out of six is near 0.05. This indicates that the MCMC outputs can be considered as being drawn from the same distributions.</p>
<p>These parameters are summarized in the next tables.</p>
<p>Table: Summary of the statistical parameters of the Nimble Coda.Geweke model:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="right">Mean</th>
<th align="right">SD</th>
<th align="right">Naive SE</th>
<th align="right">Time-series SE</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">population.mean</td>
<td align="right">599.698</td>
<td align="right">0.949</td>
<td align="right">0.025</td>
<td align="right">0.026</td>
</tr>
<tr>
<td align="left">population.sd</td>
<td align="right">31.071</td>
<td align="right">0.671</td>
<td align="right">0.017</td>
<td align="right">0.021</td>
</tr>
</tbody>
</table>
<p>Table: Summary of the statistical parameters of the Nimble Geweke model:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="right">Mean</th>
<th align="right">SD</th>
<th align="right">Naive SE</th>
<th align="right">Time-series SE</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">population.mean</td>
<td align="right">599.668</td>
<td align="right">0.973</td>
<td align="right">0.026</td>
<td align="right">0.025</td>
</tr>
<tr>
<td align="left">population.sd</td>
<td align="right">31.081</td>
<td align="right">0.688</td>
<td align="right">0.019</td>
<td align="right">0.020</td>
</tr>
</tbody>
</table>
<p>Table: Summary of the statistical parameters of the Nimble default model:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="right">Mean</th>
<th align="right">SD</th>
<th align="right">Naive SE</th>
<th align="right">Time-series SE</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">population.mean</td>
<td align="right">599.703</td>
<td align="right">0.992</td>
<td align="right">0.025</td>
<td align="right">0.028</td>
</tr>
<tr>
<td align="left">population.sd</td>
<td align="right">31.085</td>
<td align="right">0.680</td>
<td align="right">0.017</td>
<td align="right">0.016</td>
</tr>
</tbody>
</table>
<p>We notice that parameter values are very close, that naive standard errors (SEs) are very close to Time-series SEs - which is linked to the automatic tuning of the thinning parameter which produces output samples which are nearly independent - and that differences between mean estimators are within several units of Time series-SEs - which we interpret is mostly due to the control of convergence.</p>
<h2 id="jags">JAGS</h2>
<p>We now turn to analyzing the same data with the same statistical model using <code>JAGS</code> with <code>runMCMC_btadjust()</code>. We rely on the data simulated above. In <code>JAGS</code>, we now put all the data in the same list:</p>
<pre><code class="language-r">
ModelData &lt;-list(mass = y1000, nobs = length(y1000))

</code></pre>
<p>We then propose the use of <code>JAGS</code> with a specification of the model from within R - which we find more convenient. We therefore write the model within <code>R</code> as a character chain:</p>
<pre><code class="language-r">
modeltotransfer&lt;-&quot;model {

		# Priors
			population.mean ~ dunif(0,5000)
			population.sd ~ dunif(0,100)

			# Normal distribution parameterized by precision = 1/variance in Jags
    	population.variance &lt;- population.sd * population.sd
      precision &lt;- 1 / population.variance

			# Likelihood
			for(i in 1:nobs){
			  mass[i] ~ dnorm(population.mean, precision)
			}
		}&quot;

</code></pre>
<p>The other objects useful or required for running <code>runMCMC_btadjust</code> with <code>JAGS</code> are similar to those required with <code>NIMBLE</code> (<code>Inits</code>, <code>Nchains</code>, <code>params</code>) and are not repeated here.</p>
<p>We then launch <code>runMCMC_btadjust()</code> with <code>MCMC_language=&quot;Jags&quot;</code>, specifying arguments <code>code</code> and <code>data</code> which are required in this case:</p>
<pre><code class="language-r">
set.seed(1)
out.mcmc.Jags&lt;-runMCMC_btadjust(code=modeltotransfer,  data = ModelData, MCMC_language=&quot;Jags&quot;, 
    Nchains=Nchains, params=params, inits=Inits,
    niter.min=1000,niter.max=300000,
    nburnin.min=100,nburnin.max=200000,
    thin.min=1,thin.max=1000,
		conv.max=1.05,neff.min=1000)
#&gt; Compiling model graph
#&gt;    Resolving undeclared variables
#&gt;    Allocating nodes
#&gt; Graph information:
#&gt;    Observed stochastic nodes: 1000
#&gt;    Unobserved stochastic nodes: 2
#&gt;    Total graph size: 1009
#&gt; 
#&gt; Initializing model
#&gt; 
#&gt; [1] &quot;###################################################################################&quot;
</code></pre>
<p>Note that if we had written the <code>JAGS</code> code in a text file named <code>&quot;ModelJags.txt&quot;</code>, we would just have replaced in the command above <code>code=modeltotransfer</code> by <code>code=&quot;ModelJags.txt&quot;</code>.</p>
<p>Table: Summary of the statistical parameters of the Jags model:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="right">Mean</th>
<th align="right">SD</th>
<th align="right">Naive SE</th>
<th align="right">Time-series SE</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">population.mean</td>
<td align="right">599.640</td>
<td align="right">1.009</td>
<td align="right">0.019</td>
<td align="right">0.023</td>
</tr>
<tr>
<td align="left">population.sd</td>
<td align="right">31.081</td>
<td align="right">0.681</td>
<td align="right">0.013</td>
<td align="right">0.016</td>
</tr>
</tbody>
</table>
<p>Results seem in line with those of <code>NIMBLE</code>. We check this using a paired Kolmogorov-Smirnov tests with <code>NIMBLE</code> models:</p>
<p>Table: P-values of paired Kolmogorov-Smirnov tests of output parameters (columns) of the Jags model with the three NIMBLE models (rows):</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="right">mean</th>
<th align="right">sd</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Nimble.Geweke vs. Jags</td>
<td align="right">0.46917</td>
<td align="right">0.56941</td>
</tr>
<tr>
<td align="left">Nimble.Coda.Geweke vs. Jags</td>
<td align="right">0.01296</td>
<td align="right">0.28274</td>
</tr>
<tr>
<td align="left">Nimble.Default vs. Jags</td>
<td align="right">0.16106</td>
<td align="right">0.81861</td>
</tr>
</tbody>
</table>
<p>Our results do confirm that the <code>JAGS</code> result cannot be considered as stemming from a different probability distribution than <code>NIMBLE</code> results.</p>
<p>We finally compare the efficiency of the <code>JAGS</code> and default <code>NIMBLE</code> MCMCs:</p>
<p>Table: Comparison of the efficiency of the default NIMBLE model and the Jags model:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="right">Nimble.default</th>
<th align="right">Jags</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">converged</td>
<td align="right">1.0000</td>
<td align="right">1.0000</td>
</tr>
<tr>
<td align="left">burnin</td>
<td align="right">574.0000</td>
<td align="right">101.0000</td>
</tr>
<tr>
<td align="left">thin</td>
<td align="right">7.0000</td>
<td align="right">1.0000</td>
</tr>
<tr>
<td align="left">niter.tot</td>
<td align="right">4226.0000</td>
<td align="right">1000.0000</td>
</tr>
<tr>
<td align="left">duration</td>
<td align="right">62.5618</td>
<td align="right">6.5757</td>
</tr>
<tr>
<td align="left">duration.MCMC.preparation</td>
<td align="right">55.7112</td>
<td align="right">3.3053</td>
</tr>
<tr>
<td align="left">duration.MCMC.transient</td>
<td align="right">0.2024</td>
<td align="right">1.3781</td>
</tr>
<tr>
<td align="left">duration.MCMC.asymptotic</td>
<td align="right">1.2878</td>
<td align="right">1.1253</td>
</tr>
<tr>
<td align="left">duration.btadjust</td>
<td align="right">5.3603</td>
<td align="right">0.7671</td>
</tr>
<tr>
<td align="left">CPUduration</td>
<td align="right">17.0400</td>
<td align="right">5.1400</td>
</tr>
<tr>
<td align="left">CPUduration.MCMC.preparation</td>
<td align="right">14.0400</td>
<td align="right">2.5800</td>
</tr>
<tr>
<td align="left">CPUduration.MCMC.transient</td>
<td align="right">0.2037</td>
<td align="right">1.3762</td>
</tr>
<tr>
<td align="left">CPUduration.MCMC.asymptotic</td>
<td align="right">1.2963</td>
<td align="right">1.1238</td>
</tr>
<tr>
<td align="left">CPUduration.btadjust</td>
<td align="right">1.5000</td>
<td align="right">0.0600</td>
</tr>
</tbody>
</table>
<p>The conclusion is that <code>JAGS</code> is much faster than <code>NIMBLE</code> on this example (row named <code>duration</code> in the previous table), due to much less time devoted to MCMC preparation - as well as to burn-in/thinning adjustment (rows named <code>duration.MCMC.preparation</code> and <code>duration.btadjust</code> in the previous table). Actually there is no adjustment with <code>JAGS</code> (<code>niter.tot</code> is equal to the initial number of iterations). Yet, <code>NIMBLE</code> is quicker regarding MCMC updating by iteration since it took <code>NIMBLE</code> less time than <code>JAGS</code> for the transient phase (respectively less than twice time for the asymptotic phase) although using more than seven (resp. seventeen) times more iterations than <code>JAGS</code>.</p>
<p>At first sight, we would also conclude that MCMC efficiency per effective value is also better with <code>NIMBLE</code> since both languages had the same target for the minimum number of effective value - 1,000 - and the total MCMC time was lower with <code>NIMBLE</code>. Yet, a more rigorous comparison finds the reverse result:</p>
<p>Table: Comparison of the number of effective values between the default NIMBLE model and the JAGS model:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="right">Nimble.default</th>
<th align="right">Jags</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Min. Number Eff. values</td>
<td align="right">1208.000000</td>
<td align="right">1699.000000</td>
</tr>
<tr>
<td align="left">MCMC CPU time per Effective Value</td>
<td align="right">0.001242</td>
<td align="right">0.001471</td>
</tr>
</tbody>
</table>
<p>Indeed, <code>JAGS</code> with just the first iterations produced a high number of effective values - actually much bigger than the targeted <code>neff.min</code>  - which renders the MCMC time per effective value now lower with <code>JAGS</code> than <code>NIMBLE</code> with this model (cf. table above).</p>
<h2 id="greta">Greta</h2>
<p>We finally run the <code>greta</code> version of our model with <code>runMCMC_btadjust()</code>. <code>greta</code> is rather different from <code>JAGS</code> and <code>NIMBLE</code> in that the model defines objects in R and thus does not require a model code to be passed to <code>runMCMC_btadjust()</code>, nor Data or Constants. We rely on the very data simulated above. The coding with <code>greta</code> is as follows:</p>
<pre><code class="language-r">#in my setting I need to load not only greta but R6 &amp; tensorflow packages
library(greta)
library (R6)
library(tensorflow)

#first requirement of greta: declaring the data that will be analyzed with the function as_data
Y&lt;-as_data(y1000)

#we then proceed by writing the model directly in R, starting with the priors of the parameters using greta functions for probability distributions - here uniform()
population.mean&lt;-uniform(0,5000)
population.sd&lt;-uniform(0,100)
    
#we then define the distribution of the data - here with the normal distribution - by default parametrized with a standard deviation in greta:
try({distribution(Y)&lt;-normal(population.mean,population.sd) })

#we finally declare the greta model, which will be the object passed to runMCMC_btadjust 
m&lt;-model(population.mean, population.sd)

### we finally have to prepare initial values with a specific greta function - initials:
ModelInits &lt;- function()
    {initials(population.mean = rnorm(1,600,90), population.sd = runif(1, 1, 30))}

set.seed(1)
  Inits&lt;-lapply(1:Nchains,function(x){ModelInits()})
</code></pre>
<p>We are now ready to fit the model with <code>runMCMC_btadjust()</code>, specifying <code>MCMC_language=&quot;Greta&quot;</code> and giving the argument <code>model</code> instead of <code>code</code> and <code>data</code>:</p>
<pre><code class="language-r">out.mcmc.greta&lt;-runMCMC_btadjust(model=m, MCMC_language=&quot;Greta&quot;,
    Nchains=Nchains,params=params,inits=Inits,
		niter.min=1000,niter.max=300000,
    nburnin.min=100,nburnin.max=200000,
		thin.min=1,thin.max=1000,
		conv.max=1.05, neff.min=1000)
#&gt; [1] &quot;###################################################################################&quot;
#&gt; 
#&gt; [1] &quot;raw multiplier of thin:  5.319&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; [1] &quot;Case of niter update: Convergence and trying to reach end of MCMC at the end of next cycle&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; 
#&gt; [1] &quot;raw multiplier of thin:  1.695&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; [1] &quot;Case of niter update: Convergence and trying to reach end of MCMC at the end of next cycle&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; 
#&gt; [1] &quot;raw multiplier of thin:  1.391&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; [1] &quot;Case of niter update: Convergence and trying to reach end of MCMC at the end of next cycle&quot;
#&gt; [1] &quot;###################################################################################&quot;
#&gt; [1] &quot;###################################################################################&quot;
</code></pre>
<p>Table: Summary of the statistical parameters of the greta model:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="right">Mean</th>
<th align="right">SD</th>
<th align="right">Naive SE</th>
<th align="right">Time-series SE</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">population.mean</td>
<td align="right">599.630</td>
<td align="right">1.012</td>
<td align="right">0.026</td>
<td align="right">0.029</td>
</tr>
<tr>
<td align="left">population.sd</td>
<td align="right">31.092</td>
<td align="right">0.696</td>
<td align="right">0.018</td>
<td align="right">0.017</td>
</tr>
</tbody>
</table>
<p>We first check that estimations are similar to those with <code>NIMBLE</code> and <code>JAGS</code> with paired Kolmogorov-Smirnov tests:</p>
<p>Table: P-values of paired Kolmogorov-Smirnov tests of output parameters of the greta model with the default NIMBLE model and the JAGS model:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="right">mean</th>
<th align="right">sd</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Nimble vs. greta</td>
<td align="right">0.1196</td>
<td align="right">0.8388</td>
</tr>
<tr>
<td align="left">Jags vs. greta</td>
<td align="right">0.4162</td>
<td align="right">0.7813</td>
</tr>
</tbody>
</table>
<p>We then report the efficiency of the MCMCs.</p>
<p>Table: Comparison of the efficiency of the default NIMBLE, the JAGS and the greta models:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="right">Nimble.default</th>
<th align="right">Jags</th>
<th align="right">Greta</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">converged</td>
<td align="right">1.0000</td>
<td align="right">1.0000</td>
<td align="right">1.0000</td>
</tr>
<tr>
<td align="left">burnin</td>
<td align="right">574.0000</td>
<td align="right">101.0000</td>
<td align="right">1.0000</td>
</tr>
<tr>
<td align="left">thin</td>
<td align="right">7.0000</td>
<td align="right">1.0000</td>
<td align="right">10.0000</td>
</tr>
<tr>
<td align="left">niter.tot</td>
<td align="right">4226.0000</td>
<td align="right">1000.0000</td>
<td align="right">5020.0000</td>
</tr>
<tr>
<td align="left">duration</td>
<td align="right">62.5618</td>
<td align="right">6.5757</td>
<td align="right">58.2215</td>
</tr>
<tr>
<td align="left">duration.MCMC.preparation</td>
<td align="right">55.7112</td>
<td align="right">3.3053</td>
<td align="right">0.3747</td>
</tr>
<tr>
<td align="left">duration.MCMC.transient</td>
<td align="right">0.2024</td>
<td align="right">1.3781</td>
<td align="right">8.9018</td>
</tr>
<tr>
<td align="left">duration.MCMC.asymptotic</td>
<td align="right">1.2878</td>
<td align="right">1.1253</td>
<td align="right">44.6333</td>
</tr>
<tr>
<td align="left">duration.btadjust</td>
<td align="right">5.3603</td>
<td align="right">0.7671</td>
<td align="right">4.3117</td>
</tr>
<tr>
<td align="left">CPUduration</td>
<td align="right">17.0400</td>
<td align="right">5.1400</td>
<td align="right">201.0100</td>
</tr>
<tr>
<td align="left">CPUduration.MCMC.preparation</td>
<td align="right">14.0400</td>
<td align="right">2.5800</td>
<td align="right">0.0000</td>
</tr>
<tr>
<td align="left">CPUduration.MCMC.transient</td>
<td align="right">0.2037</td>
<td align="right">1.3762</td>
<td align="right">33.3855</td>
</tr>
<tr>
<td align="left">CPUduration.MCMC.asymptotic</td>
<td align="right">1.2963</td>
<td align="right">1.1238</td>
<td align="right">167.3945</td>
</tr>
<tr>
<td align="left">CPUduration.btadjust</td>
<td align="right">1.5000</td>
<td align="right">0.0600</td>
<td align="right">0.2300</td>
</tr>
</tbody>
</table>
<p>MCMC time (rows <code>duration.MCMC.transient</code> &amp; <code>duration.MCMC.asymptotic</code>) was far greater with <code>greta</code> than with <code>JAGS</code> and <code>NIMBLE</code>, for a minimum number of effective values with <code>greta</code> of 1043. Total duration is rather close with <code>greta</code> compared with <code>NIMBLE</code>, due to the great time required by <code>NIMBLE</code> for MCMC preparation - while this preparation is done outside <code>runMCMC_btadjust()</code> with <code>greta</code>. Yet, when we compare CPU total durations (<code>CPUduration</code>), <code>greta</code> gets worse than <code>NIMBLE</code>, simply because <code>greta</code> parallelized its process and therefore required more CPU time per time unit.</p>
<p>We tried to give a second chance to <code>greta</code>, based on the following post: <a href="https://forum.greta-stats.org/t/size-and-number-of-leapfrog-steps-in-hmc/332">https://forum.greta-stats.org/t/size-and-number-of-leapfrog-steps-in-hmc/332</a>. The idea was to let <code>greta</code> have more information to adapt its hmc parameters during the warm-up phase by just having more chains to run - hereafter, 15.</p>
<pre><code class="language-r">Nchains&lt;-15
ModelInits &lt;- function()
    {initials(population.mean = rnorm(1,600,90), population.sd = runif(1, 1, 30))}

set.seed(1)
Inits&lt;-lapply(1:Nchains,function(x){ModelInits()})
  
  out.mcmc.greta.morechains&lt;-runMCMC_btadjust(model=m, MCMC_language=&quot;Greta&quot;,
    Nchains=Nchains,params=params,inits=Inits,
		niter.min=1000,niter.max=300000,
    nburnin.min=100,nburnin.max=200000,
		thin.min=1,thin.max=1000,
		conv.max=1.05, neff.min=1000)
#&gt; [1] &quot;###################################################################################&quot;
</code></pre>
<p>Table: Summary of the statistical parameters of the greta model with 15 chains:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="right">Mean</th>
<th align="right">SD</th>
<th align="right">Naive SE</th>
<th align="right">Time-series SE</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">population.mean</td>
<td align="right">599.6795</td>
<td align="right">0.9773</td>
<td align="right">0.0080</td>
<td align="right">0.0167</td>
</tr>
<tr>
<td align="left">population.sd</td>
<td align="right">31.1107</td>
<td align="right">0.7087</td>
<td align="right">0.0058</td>
<td align="right">0.0110</td>
</tr>
</tbody>
</table>
<p>This run was indeed much faster. Parameter estimates were still not significantly different from those with <code>NIMBLE</code> and <code>JAGS</code> based on paired Kolmogorov-Smirnov tests:</p>
<p>Table: P-values of paired Kolmogorov-Smirnov tests of output parameters of the greta model with 15 chains with the default NIMBLE model and the JAGS model:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="right">mean</th>
<th align="right">sd</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Nimble vs. greta.morechains</td>
<td align="right">0.37848</td>
<td align="right">0.08594</td>
</tr>
<tr>
<td align="left">Jags vs. greta.morechains</td>
<td align="right">0.13618</td>
<td align="right">0.09811</td>
</tr>
</tbody>
</table>
<p>We now report the efficiency of the MCMCs:</p>
<p>Table: Comparison of the efficiency of the default NIMBLE, the JAGS and the greta.morechains models:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="right">Nimble.default</th>
<th align="right">Jags</th>
<th align="right">Greta.morechains</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">converged</td>
<td align="right">1.0000</td>
<td align="right">1.0000</td>
<td align="right">1.0000</td>
</tr>
<tr>
<td align="left">burnin</td>
<td align="right">574.0000</td>
<td align="right">101.0000</td>
<td align="right">1.0000</td>
</tr>
<tr>
<td align="left">thin</td>
<td align="right">7.0000</td>
<td align="right">1.0000</td>
<td align="right">1.0000</td>
</tr>
<tr>
<td align="left">niter.tot</td>
<td align="right">4226.0000</td>
<td align="right">1000.0000</td>
<td align="right">1000.0000</td>
</tr>
<tr>
<td align="left">duration</td>
<td align="right">62.5618</td>
<td align="right">6.5757</td>
<td align="right">28.9295</td>
</tr>
<tr>
<td align="left">duration.MCMC.preparation</td>
<td align="right">55.7112</td>
<td align="right">3.3053</td>
<td align="right">0.4071</td>
</tr>
<tr>
<td align="left">duration.MCMC.transient</td>
<td align="right">0.2024</td>
<td align="right">1.3781</td>
<td align="right">13.8047</td>
</tr>
<tr>
<td align="left">duration.MCMC.asymptotic</td>
<td align="right">1.2878</td>
<td align="right">1.1253</td>
<td align="right">13.7771</td>
</tr>
<tr>
<td align="left">duration.btadjust</td>
<td align="right">5.3603</td>
<td align="right">0.7671</td>
<td align="right">0.9406</td>
</tr>
<tr>
<td align="left">CPUduration</td>
<td align="right">17.0400</td>
<td align="right">5.1400</td>
<td align="right">120.8900</td>
</tr>
<tr>
<td align="left">CPUduration.MCMC.preparation</td>
<td align="right">14.0400</td>
<td align="right">2.5800</td>
<td align="right">0.0200</td>
</tr>
<tr>
<td align="left">CPUduration.MCMC.transient</td>
<td align="right">0.2037</td>
<td align="right">1.3762</td>
<td align="right">60.3803</td>
</tr>
<tr>
<td align="left">CPUduration.MCMC.asymptotic</td>
<td align="right">1.2963</td>
<td align="right">1.1238</td>
<td align="right">60.2597</td>
</tr>
<tr>
<td align="left">CPUduration.btadjust</td>
<td align="right">1.5000</td>
<td align="right">0.0600</td>
<td align="right">0.2300</td>
</tr>
</tbody>
</table>
<p>We still observed more CPU duration with <code>greta</code>, although the difference had decreased and the associated number of effective values for <code>greta</code> was now 3329, which rendered MCMC CPU efficiency with <code>greta</code> closer to <code>NIMBLE</code>. Yet, overall, <code>JAGS</code> performed better than <code>greta</code> and <code>NIMBLE</code> on this example.</p>
<h1 id="conclusion">Conclusion</h1>
<p>We hope we have convinced the R user of Bayesian models that <code>runMCMC_btadjust()</code> can help having a more efficient, quality oriented use of these types of models while saving analyst’s and potentially computer time. Indeed, to recap, the aim of this function is to run a Markov Chain Monte Carlo (MCMC) for a specified Bayesian model while adapting automatically the burn-in and thinning parameters to meet pre-specified targets in terms of MCMC convergence and number of effective values of MCMC outputs. This is done in only one call to the function that repeatedly calls the MCMC until criteria for convergence and number of effective values are met. The function has four main advantages:</p>
<p>(i) it saves the analyst’s programming time since he/she does not have to repeatedly diagnose and re-run MCMCs until desired levels of convergence and number of effective values are reached;</p>
<p>(ii) it allows a minimal, normalized quality control of MCMC outputs by allowing to meet pre-specified levels in terms of convergence and number of quasi-independent values;</p>
<p>(iii) it may save computer’s time when compared to cases where we have to restart the MCMC from the beginning if it has not converged or reached the specified number of effective values;</p>
<p>(iv) it can be applied with different MCMC R languages - at present <code>greta</code>, <code>NIMBLE</code> and <code>JAGS</code>. This comes with two positive consequences in practice: first, allowing the user a more rigorous comparison between the three Bayesian fitting languages in terms of comparability of inference and of MCMC efficiency - especially in terms of CPU time per effective value; second, making it easier to develop the same Bayesian model with these different languages, which is to our experience welcome in practical cases, since these different languages have advantages over the other ones that vary from one context to the other.</p>
<h1 id="references">References</h1>
</div>
<div class="include-after">
</div>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
</body>
</html>
